<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket-4.3.xsd
		http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />
	
	<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<resources mapping="/resources/**" location="/resources/" />

	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<context:component-scan base-package="com.kh.spring" />
	
	<!-- @Transactional 어노테이션 활성화 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>
	 
	
	<!-- ======================= Intercepter 시작 ====================== -->
	<!-- 
		인터셉터(Interceptor)
		  - DispatcherServlet → Controller 사이에서 요청(request)을 가로채는 컴포넌트
		  - 공통 관심사(로그인, 권한 체크, 로깅 등)를 분리하여 관리할 수 있음 (AOP와 유사한 역할)
		  - 스프링의 빈 객체로 등록되므로 다른 서비스, DAO 등의 의존성 주입이 가능함
	
	 	사용 목적 예시:
		  - 로그인 여부 확인
		  - 특정 URL 접근 제한 (권한 처리)
		  - 요청/응답 시간 측정
		  - 공통 데이터 처리 (예: 게시판 분류 목록 조회)
	
	-->
	<interceptors>
	 	<interceptor>
	 		<mapping path="/board/update/**"/>
	 		<mapping path="/board/delete/**"/>
	 		<beans:bean class="com.kh.spring.common.interceptor.BoardOwnerCheckInterceptor"/>
	 	</interceptor>
	</interceptors>
	<!-- ======================= Intercepter 끝 ====================== -->
	
	<!-- ======================= 웹소켓 시작 ============================ 
		Http / HTTPS
		- 클라이언트(브라우저)와 웹서버 간에 요청(Request)과 응답(Response) 기반으로 동작하는 전통적인 통신 방식.
		- 요청이 있어야만 응답이 발생하는 단방향 통신 구조 (Request → Response).
		- 연결을 "유지하지 않고" 요청 시마다 새로 연결을 맺기 때문에, 실시간 처리(채팅, 주식시세, 게임)가 어려움.			
		- 구현이 단순하고 범용적이므로 개발과 운영이 쉬움.			  

		WebSocket
		- 클라이언트와 서버 간의 지속적인 연결(persistent connection)을 유지하며, 
			양방향 통신(Full Duplex)을 지원하는 프로토콜.(전화)
			- 양방향 통신(Full Duplex) : 양쪽 장치가 동시에 송신과 수신을 독립적으로 할 수 있는 통신 방식. 
			ex) 전화 통화
		- 서버와 클라이언트가 서로 "실시간"으로 데이터를 주고 받을 수 있음 
		- 실시간성이 중요한 서비스(예: 채팅, 주식시세, 게임 등)에 적합.
		- 일반 HTTP보다 구현이 다소 복잡하고, 연결 수 유지에 따른 리소스 관리가 필요함.

		WebSocket사용을 위한 스펙
		- HTML은 HTML5부터 Websocket 지원.
		- Java에서는 7버전 부터 WebSocket 지원.
		- Spring Framework에서는 4.0 이상부터 WebSocket 지원.
		- 웹소켓 모듈 필요.(spring-websocket, spring-messaging)

		WebSocket의 동작방식
			- 첫 연결은 HTTP 프로토콜을 사용하여 연결하고 연결 성공시 WebSocket 통신으로 전환된다.
			- 연결 후에는 데이터프레임을 주고 받는다.(헤더를 최소화하여 실제 데이터만 주고받음.)			

		SockJS
			- WebSocket을 지원하지 않는 환경에서도 WebSocket처럼 동작하게 해주는 자바스크립트 라이브러리.
			- WebSocket을 사용할 수 없는 경우, 내부적으로 XHR, Long Polling(주기적인 비동기 요청) 등을 통해 유사한 기능을 제공
			- 즉 WebSocket의 하위호환성을 확보하기 위한 라이브러리다.(통신채널 수립이 목적)
			- WebSocket/Sockjs는 "메시지를 실시간으로 송수신이 가능한 양방향 채널"일 뿐, 특별한 기능 및 규약(메세지의 목적성, 형식 등)은 존재하지 않는다.	
			- 만약 내가 구현하고자 하는 기능이 특정 채널을 구독하고 있는 사용자에게 채널에 새로운 게시글이 올라올 때 마다 서버에서
			  실시간으로 사용자에게 알림을 보내는 기능처럼 복잡한 기능을 만들고 싶다면, WebSocket/Sockjs만으로는 부족 하다.(가능은 하나 손이 많이감)
				
		STOMP(Simple Text Oriented Messaging Protocol)+ 
		    - 텍스트 기반의 메시징 프로토콜로, WebSocket 위에서 동작하며
		      메시지에 "구독", "전송 목적지", "메시지 유형","헤더" ,바디" 등을 프레임 단위로 묶어서 전송한다.
		    - 이를 통해 구독 기반 메세지 처리, 사용자 그룹 알림 등을 체꼐적으로 처리할 수 있다.
			- 스톰프로 전송하는 메세지 프레임은 
			  메시지의 타입(CONNECT, SUBSCRIBE, UNSUBSCRIBE, SEND, DISCONNECT)과 
			  메시지 헤더(content-length, content-type, destination),
			  메시지 바디(메시지 내용)가 포함된다.
	-->


	<!-- 웹소켓 요청시 해당 요청내용들을 처리해줄 클래스.(메세지 전송, 커넥션연결요청, 해제) -->
	<beans:bean id="chatHandler" class="com.kh.spring.chat.model.websocket.ChatWebsocket"></beans:bean>
	
	<websocket:handlers>
		<!-- 웹소켓 요청 주소를 처리한 bean객체 -->
		<websocket:mapping handler="chatHandler" path="/chat"/>
		
		<!-- 
			첫 웹소켓 연결 수립시 httpSession의 attribute들을 websocketSession으로 
			복사해주는 인터셉터.				
		-->
		<websocket:handshake-interceptors>
			<beans:bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"></beans:bean>
			<beans:bean class="com.kh.spring.common.interceptor.CustomHandshakeInterceptor"></beans:bean>
		</websocket:handshake-interceptors>
		
		<!-- SockJs라이브러리를 이용해서 만들어진 웹소켓 객체 -->
		<websocket:sockjs></websocket:sockjs>
	</websocket:handlers>
	
	
</beans:beans>
