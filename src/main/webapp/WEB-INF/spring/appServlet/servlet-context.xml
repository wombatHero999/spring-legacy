<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:websocket="http://www.springframework.org/schema/websocket"
	xsi:schemaLocation="http://www.springframework.org/schema/websocket http://www.springframework.org/schema/websocket/spring-websocket-4.3.xsd
		http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />
	
	<!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<resources mapping="/resources/**" location="/resources/" />

	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<context:component-scan base-package="com.kh.spring" />
	
	<!-- @Transactional 어노테이션 활성화 -->
	<tx:annotation-driven transaction-manager="transactionManager"/>
	 
	
	<!-- ======================= Intercepter 시작 ====================== -->
	<!-- 
		인터셉터(Interceptor)
		  - DispatcherServlet → Controller 사이에서 요청(request)을 가로채는 컴포넌트
		  - 공통 관심사(로그인, 권한 체크, 로깅 등)를 분리하여 관리할 수 있음 (AOP와 유사한 역할)
		  - 스프링의 빈 객체로 등록되므로 다른 서비스, DAO 등의 의존성 주입이 가능함
	
	 	사용 목적 예시:
		  - 로그인 여부 확인
		  - 특정 URL 접근 제한 (권한 처리)
		  - 요청/응답 시간 측정
		  - 공통 데이터 처리 (예: 게시판 분류 목록 조회)
	
	-->
	<interceptors>
	 	<interceptor>
	 		<mapping path="/board/update/**"/>
	 		<mapping path="/board/delete/**"/>
	 		<beans:bean class="com.kh.spring.common.interceptor.BoardOwnerCheckInterceptor"/>
	 	</interceptor>
	</interceptors>
	<!-- ======================= Intercepter 끝 ====================== -->
	
	<!-- ======================= 웹소켓 시작 ============================ 
		Http / HTTPS
		- 클라이언트(브라우저)와 웹서버 간에 요청(Request)과 응답(Response) 기반으로 동작하는 전통적인 통신 방식.
		- 요청이 있어야만 응답이 발생하는 단방향 통신 구조 (Request → Response).
		- 연결을 "유지하지 않고" 요청 시마다 새로 연결을 맺기 때문에, 실시간 처리(채팅, 주식시세, 게임)가 어려움.			
		- 구현이 단순하고 범용적이므로 개발과 운영이 쉬움.			  

		WebSocket
		- 클라이언트와 서버 간의 지속적인 연결(persistent connection)을 유지하며, 
			양방향 통신(Full Duplex)을 지원하는 프로토콜.(전화)
			- 양방향 통신(Full Duplex) : 양쪽 장치가 동시에 송신과 수신을 독립적으로 할 수 있는 통신 방식. 
			ex) 전화 통화
		- 서버와 클라이언트가 서로 "실시간"으로 데이터를 주고 받을 수 있음 
		- 실시간성이 중요한 서비스(예: 채팅, 주식시세, 게임 등)에 적합.
		- 일반 HTTP보다 구현이 다소 복잡하고, 연결 수 유지에 따른 리소스 관리가 필요함.

		WebSocket사용을 위한 스펙
		- HTML은 HTML5부터 Websocket 지원.
		- Java에서는 7버전 부터 WebSocket 지원.
		- Spring Framework에서는 4.0 이상부터 WebSocket 지원.
		- 웹소켓 모듈 필요.(spring-websocket, spring-messaging)

		WebSocket의 동작방식
			- 첫 연결은 HTTP 프로토콜을 사용하여 연결하고 연결 성공시 WebSocket 통신으로 전환된다.
			- 연결 후에는 데이터프레임을 주고 받는다.(헤더를 최소화하여 실제 데이터만 주고받음.)			

		SockJS
			- WebSocket을 지원하지 않는 환경에서도 WebSocket처럼 동작하게 해주는 자바스크립트 라이브러리.
			- WebSocket을 사용할 수 없는 경우, 내부적으로 XHR, Long Polling(주기적인 비동기 요청) 등을 통해 유사한 기능을 제공
			- 즉 WebSocket의 하위호환성을 확보하기 위한 라이브러리다.(통신채널 수립이 목적)
			- WebSocket/Sockjs는 "메시지를 실시간으로 송수신이 가능한 양방향 채널"일 뿐, 특별한 기능 및 규약(메세지의 목적성, 형식 등)은 존재하지 않는다.	
			- 만약 내가 구현하고자 하는 기능이 특정 채널을 구독하고 있는 사용자에게 채널에 새로운 게시글이 올라올 때 마다 서버에서
			  실시간으로 사용자에게 알림을 보내는 기능처럼 복잡한 기능을 만들고 싶다면, WebSocket/Sockjs만으로는 부족 하다.(가능은 하나 손이 많이감)
				
		STOMP(Simple Text Oriented Messaging Protocol)+ 
		 - WebSocket위에서 동작하는 메시징 프로토콜
		 - 메시지에 "목적지(Destination)", 
		 		 "구독(Subscribe-url)", 
		         "명령(CONNECT, SUBSCRIBE, UNSUBSCRIBE, SEND, DISCONNECT)",
		         "헤더(content-length, content-type, destination)",
		         "바디(본문)"를 부여해 의미있는 통신을 가능하게 한다.
	     - 이를 통해 구독/발행 기반 메세지 처리, 사용자 그룹 알림 등을 쉽게 구현할 수 있다.
		
		STOMP 동작 방식
		 1. 클라이언트가 SockJS와 STOMP를 이용하여 서버에 WS "연결 요청"을 보냄
		    목적지 : stomp-endpoint
		    명령 : CONNECT
		    헤더 : ?
		    바디 : ?
		    - 연결 수락시 서버는 CONNECTED프레임을 웹소켓을 통해 반환
		 2. 클라이언트는 서버와 연결 수립 후 "구독하는 채널"을 전달 -> 브로커 객체가 관리
		    - 서버는 해당 채널로 전송되는 메시지를 클라이언트에게 푸시
		 3. 클라이언트가 서버에게 메시지를 전달(SEND)
		 4. 서버는 클라이언트가 전달한 메시지를 받아 특정 구독 채널에 메시지를 전송
		 5. 채널을 구독한 클라이언트는 실시간으로 메시지를 수신
		 6. 메시지 수신시 지정한 콜백함수 실행
		 7. 연결종료
		  
		    
		 
		 
	-->


	<!-- 웹소켓 요청시 해당 요청내용들을 처리해줄 클래스.(메세지 전송, 커넥션연결요청, 해제) -->
	<beans:bean id="chatHandler" class="com.kh.spring.chat.model.websocket.ChatWebsocket"></beans:bean>
	
	<websocket:handlers>
		<!-- 웹소켓 요청 주소를 처리한 bean객체 -->
		<websocket:mapping handler="chatHandler" path="/chat"/>
		
		<!-- 
			첫 웹소켓 연결 수립시 httpSession의 attribute들을 websocketSession으로 
			복사해주는 인터셉터.				
		-->
		<websocket:handshake-interceptors>
			<beans:bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"></beans:bean>
			<beans:bean class="com.kh.spring.common.interceptor.CustomHandshakeInterceptor"></beans:bean>
		</websocket:handshake-interceptors>
		
		<!-- SockJs라이브러리를 이용해서 만들어진 웹소켓 객체 -->
		<websocket:sockjs></websocket:sockjs>
	</websocket:handlers>
	
	<!-- 
		application-destination-prefix
		 - 클라이언트가 서버로 메시지를 보낼 경로
		 
		websocket:simple-broker
		 - 클라리언트가 메시지를 받을 구독 경로 
	  -->
	<websocket:message-broker application-destination-prefix="/pub">
	    <websocket:stomp-endpoint path="/stomp/chat">
	        <websocket:sockjs/>
	    </websocket:stomp-endpoint>
	    <websocket:simple-broker prefix="/sub"/>
	</websocket:message-broker>
	
	
</beans:beans>
